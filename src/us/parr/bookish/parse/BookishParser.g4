parser grammar BookishParser;

@header {
import us.parr.bookish.entity.*;
import java.util.Map;
import java.util.List;
}

options {
	tokenVocab=BookishLexer;
}

/** A document is a root document: book or article. All content is
 *  in a chapter in separate file.
 */
rootdocument
	:	book EOF
	|	article EOF
	;

book:	BOOK attrs[List.of("label","author","title","version","watermark","googletracking","annotations")] END_TAG
		(ws? include)*
		(ws? data | ws? notebook_support | ws? copyright | ws? abstract_ | ws? css | ws? metadata)*
		book_content
	;

article
	:	ARTICLE attrs[List.of("version","watermark","googletracking","numbering")]? END_TAG
		(ws? include)*
		(ws? data | ws? notebook_support | ws? copyright | ws? abstract_ | ws? css | ws? metadata)*
		ws?
	;

/** A chapter doubles as a section of article or is book chapter.
 *  All chapters are in a separate file.
 */
chapter returns [ChapterDef def]
	:	CHAPTER attrs[List.of("label","author","title")] END_TAG
		(ws? abstract_)?
 		content?
 		section*
 		EOF
	;

abstract_ : ABSTRACT content END_ABSTRACT ;

data:	DATA attrs[List.of("dir")] END_TAG
		(ws? dataCopy)*
		ws?
		END_DATA
	;

css : 	CSS attrs[List.of("file")] END_TAG ;

dataCopy : DATA_COPY attrs[List.of("file")] END_TAG ;

copyright : COPYRIGHT content END_COPYRIGHT ;

metadata : METADATA attrs[List.of("title","imageurl","description","url","pagetype","twitterhandle")] END_TAG ;


notebook_support : NOTEBOOK_SUPPORT attrs[List.of("file")] END_TAG ;

book_content : content ;

include : INCLUDE attrs[List.of("file")] END_TAG ;

content
	:	(	paragraph
	 	|	BLANK_LINE
	 	|	callout
	 	|	chapquote
	 	|	sidequote
	 	|	sidenote
	 	|	sidefig
	 	|	figure
	 	|	youtube
	 	|	aside
	 	|	site
	 	|	citation
	 	|	link
	 	|	pyeval
	 	|	pyfig
	 	|	inline_py
		|	block_eqn
		|	eqn
		|	latex
		|	html
		|	ordered_list
		|	unordered_list
		|	table
		|	block_image
		|	ref
	 	|	italics
	 	|	bold
	 	|	quoted
        |   codeblock
        |	linebreak
		|	todo
		|	symbol
	 	|	text
	 	|	ws
		|	firstuse
		|	inline_code
		|	hyphen
		|	dollar
		|	star
		|	lt
	 	)+
	 ;

paragraph returns [List<EntityDef> entitiesRefd = new ArrayList<>()] : BLANK_LINE paragraph_content ;

paragraph_element
	:	eqn
    |	link
    |	italics
    |	bold
    |	image
	|	ref
	|	firstuse
	|	todo
	|	symbol
	|	inline_code
	|	inline_py
	|	linebreak
	|	html
	|	hyphen
 	|	dollar
	|	star
 	|	lt
	|	text
	|	ws_no_blank_lines
	;

paragraph_content
 	:	(paragraph_element|quoted)+
 	;

hyphen : HYPHEN ;

dollar : DOLLAR ;

star : STAR ;

lt : LT ;

link : LINK ;

italics : ITALICS ;

bold : BOLD ;

quoted : QUOTE paragraph_element+ QUOTE ;

inline_code : INLINE_CODE ;

codeblock : CODEBLOCK ;

linebreak : LINE_BREAK ;

text : TEXT | SPACE | TAB ;

section returns [SectionDef def]
 	:	SECTION attrs[List.of("label","title")] END_TAG
 	  	content?
 	  	subsection*
 	;

subsection returns [SectionDef def]
 	:	SUBSECTION attrs[List.of("label","title")] END_TAG
 	  	content?
 	  	subsubsection*
 	;

subsubsection returns [SectionDef def]
	:	SUBSUBSECTION attrs[List.of("label","title")] END_TAG
		content?
	;

site      : SITE attrs[List.of("label","url")] END_TAG ;

citation  : CITATION attrs[List.of("label","title","author")] END_TAG ;

chapquote : CHAPQUOTE attrs[List.of("quote","author")] END_TAG ;

sidequote : SIDEQUOTE attrs[List.of("label","quote","author")] END_TAG ;

sidenote  : SIDENOTE attrs[List.of("label")] END_TAG content END_SIDENOTE ;

sidefig   : SIDEFIG attrs[List.of("label","caption")] END_TAG content END_SIDEFIG ;

figure    : FIGURE attrs[List.of("label","caption")] END_TAG content END_FIGURE ;

youtube  : YOUTUBE attrs[List.of("width","height","src")] END_TAG ;

aside	  : ASIDE attrs[List.of("title")] END_TAG content END_ASIDE ;

callout   : CALLOUT attrs[List.of("label")] END_TAG content END_CALLOUT ;

pyeval returns [PyEvalDef codeDef, String stdout, String stderr, String displayData]
    :	PYEVAL attrs[List.of("label","output","hide","disable")] END_TAG pycodeblock END_PYEVAL
	;

pyfig returns [PyFigDef codeDef, String stdout, String stderr]
	:	PYFIG attrs[List.of("label","side","hide","width")] END_TAG pycodeblock END_PYFIG
	;

inline_py returns [InlinePyEvalDef codeDef, String stdout, String stderr, String displayData]
 	:	INLINE_PY attrs[List.of("label")] END_TAG pycodeblock END_PY
 	|	INLINE_PY_UNLABELED pycodeblock END_PY
 	;

pycodeblock : PYCODE_CONTENT* ;

ordered_list
	:	OL
		( ws? LI ws? list_item )+ ws?
		OL_
	;

unordered_list
	:	UL
		( ws? LI ws? list_item )+ ws?
		UL_
	;

table
	:	TABLE
			( ws? table_header )? // header row
			( ws? table_row )+ // actual rows
			ws?
		TABLE_
	;

table_header : TR table_header_item+ ;

table_row : TR table_row_item+ ;

table_row_item : ws? TD attrs[List.of("align")]? END_TAG table_item ;

table_header_item : ws? TH attrs[List.of("width","align")]? END_TAG table_item ;

list_item : content? ;

table_item : content? ;

block_image : image ;

image : IMG attrs[List.of("src","width","side","url","align","nocenter","alt")] END_TAG ;

ref : REF ;

firstuse : FIRSTUSE ;

todo : TODO ;

symbol : SYMBOL ;

latex returns [String relativeImageFilename] : LATEX latex_content END_LATEX ;

latex_content : LATEX_CONTENT+ ;

html returns [String relativeImageFilename] : HTML html_content END_HTML ;

html_content : HTML_CONTENT+ ;

block_eqn returns [String relativeImageFilename] : BLOCK_EQN ;

eqn returns [String relativeImageFilename, float height, float depth]: EQN ;

/** Callers define set of possible/valid attribute names. Checked by
 *  semantic phase not tested here.  The arg effectively annotates the
 *  tree with the valid xml attributes for the caller.
 *
 *  Note: values can be "..." (no newlines) and {...}, which are
 *  interpreted as valid bookish code. Those {...} chunks are
 *  translated during code gen phase.
 */
attrs[List<String> valid] returns [Map<String,String> attributes]
 	:	attr_assignment+
 	;

attr_assignment
	:	name=XML_ATTR XML_EQ value=(XML_ATTR_VALUE|XML_ATTR_NUM|XML_ATTR)
	;

ws : (BLANK_LINE | NL | TAB | SPACE)+ ;

ws_no_blank_lines : (NL | TAB | SPACE)+ ;